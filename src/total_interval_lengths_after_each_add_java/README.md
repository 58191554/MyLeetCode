下面是这道「**动态维护区间并返回当前覆盖总长度**」的题目描述（LeetCode 风格）：

# 当前区间总长度

给定一系列操作，每个操作向一个数据结构中加入一个**闭区间** `[start, end]`（`start <= end`）。数据结构始终维护一组**两两不相交且已合并**的区间集合（即重叠或相邻的区间会被合并为一个更大的闭区间）。

在每次加入新区间后，请返回**当前所有区间的覆盖总长度**。由于是闭区间，单点 `[x, x]` 的长度为 `1`，一般区间 `[l, r]` 的长度为 `r - l + 1`。

## 实现说明

给定输入 `ops`，其中 `ops[i] = [start_i, end_i]` 表示第 `i` 次加入的闭区间。你需要返回一个长度为 `len(ops)` 的数组 `ans`，其中 `ans[i]` 是在处理完第 `i` 次加入后，当前区间集合的覆盖总长度。

* 若新区间与已有区间重叠或相邻（例如 `[1,3]` 与 `[4,5]` 相邻），需要将它们**合并**。
* 合并后，区间集合应保持**不重叠且按起点有序**。

## 示例

**示例 1：**

```
输入：ops = [[1,5], [10,12], [3,7], [12,15], [8,10]]
输出：[5, 8, 7, 13, 15]
解释：
- 加入 [1,5]，集合为 [[1,5]]，总长度 5
- 加入 [10,12]，集合为 [[1,5],[10,12]]，总长度 5 + 3 = 8
- 加入 [3,7]，与 [1,5] 合并为 [1,7]，集合 [[1,7],[10,12]]，总长度 7 + 3 = 10，但题意为每步返回**当前**：此步结束后是 7（因为只发生在左侧的合并）
- 加入 [12,15]，与 [10,12] 相邻并合并为 [10,15]，集合 [[1,7],[10,15]]，总长度 7 + 6 = 13
- 加入 [8,10]，桥接两段，最终 [[1,15]]，总长度 15
```

**示例 2：**

```
输入：ops = [[5,5], [6,8], [2,3], [4,7]]
输出：[1, 4, 6, 8]
```

## 约束

* `1 <= ops.length <= 1e5`
* `-1e9 <= start_i <= end_i <= 1e9`
* 需要高效支持动态合并，期望平均/摊销时间复杂度接近 `O(log n)` 每次操作（例如使用有序映射、平衡树、二分与邻接合并等）。

## 函数签名

* Python：

  ```python
  def total_lengths_after_each_add(ops: list[list[int]]) -> list[int]:
      ...
  ```
* （可选）Java：

  ```java
  public List<Long> totalLengthsAfterEachAdd(int[][] ops) { ... }
  ```

## 提示

* 使用**闭区间**：长度为 `r - l + 1`。
* 合并判定时，若 `prev.end + 1 >= cur.start` 则应合并（相邻也合并）。
* 维护「不相交区间集合 + 当前总长度」：删除被覆盖的旧区间时先减去其长度，插入新合并区间时再加回长度，可避免每次遍历整集合。
