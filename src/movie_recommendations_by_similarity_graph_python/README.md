# Movie Recommendations by Similarity Graph

## 问题描述

给定：

- 一组电影及其**评分**（例如 0–10 分，或任意实数评分）。
- 若干电影之间的**相似关系**，可带权（相似度介于 0 与 1 之间，越大越相似）。相似关系可为**有向**或**无向**。
- 查询 `(movie_name, n)`。

请实现函数，返回与 `movie_name` **最相似的 n 部电影**的列表。
 相似关系**允许多跳传递**：若存在 `A→B` 与 `B→C`，则 `A` 与 `C` 也可因路径 `A→B→C` 被认为存在相似性；需要基于**全图**（而非仅一跳邻居）度量相似度并选出 Top-n。

> 目标：在排除 `movie_name` 本身后，按“综合相似度”从高到低输出前 `n` 部电影。若相似度相同，按评分更高者优先；若仍相同，按电影名字典序（或 ID 较小）打破平局。

## 相似度聚合（默认约定）

- 每条边 `u→v` 带相似度权重 `w(u,v) ∈ (0,1]`。
- 一条从源 `s` 到目标 `t` 的路径 `P = (s→…→t)` 的**路径强度**定义为**边权乘积**：
   `strength(P) = ∏ w(e)`（可选再乘以衰减 `λ^len(P)`，`λ ∈ (0,1]`）。
- `s` 到 `t` 的**综合相似度**定义为**路径强度的最大值**：
   `sim(s,t) = max_{P∈Paths(s,t)} strength(P)`
   （这等价于在对数域做最短路：`cost(e) = -log w(e)`，求最小代价路径；实现上可用“最大乘积版 Dijkstra”。）

> 你也可以与面试官沟通改用 **Personalized PageRank / Random Walk with Restart** 或“多路径求和+衰减”的相似度；但请在题面中固定一种明确可实现的定义。上面“最大乘积路径”简单、可解释、实现直接。

## 函数签名（示例）

**Python**

```python
from typing import Dict, List, Tuple

def top_n_similar_movies(
    ratings: Dict[str, float],
    similarities: List[Tuple[str, str, float]],  # (u, v, w), 0<w<=1
    query_movie: str,
    n: int,
    undirected: bool = True,   # True: 将(u,v)视为无向；False: 按输入方向
    decay: float = 1.0         # 路径衰减 λ，默认不衰减
) -> List[str]:
    ...
```

## 输入输出格式

- **输入**
  - `ratings`：电影名 → 评分。
  - `similarities`：相似边列表 `(u, v, w)`。若为无向相似度，可输入两条（`u,v,w` 与 `v,u,w`），或传参 `undirected=True` 由实现镜像为双向。
  - `query_movie`：源电影名。
  - `n`：需要返回的电影数。
- **输出**
  - 按综合相似度从高到低返回 **长度 ≤ n** 的电影名列表（当可达电影不足 n 时，返回全部可达电影）。不包含 `query_movie` 本身。

## 约束（可与面试官确认）

- 电影总数 `V` 可达 1e5；相似边 `E` 可达 5e5。
- 相似度 `w` 在 `(0, 1]`；评分为实数或整数。
- 要求在稀疏图上近似 `O((V+E) log V)` 实现（堆版 Dijkstra/最大乘积变体）；内存 `O(V+E)`。
- 图可能**不连通**；若某电影对查询源不可达，则不在候选中。

## 排序与 tie-break

1. 先按 `sim(query, movie)` 降序；
2. 再按 `ratings[movie]` 降序；
3. 再按 `movie` 名称字典序升序（或按 ID）。

## 示例

**输入**

```
ratings = {
  "A": 9.0, "B": 8.3, "C": 7.5, "D": 8.8, "E": 7.0
}
similarities = [
  ("A","B",0.9),
  ("B","C",0.8),
  ("A","D",0.6),
  ("D","E",0.95)
]
query_movie = "A"
n = 3
undirected = True
decay = 1.0
```

**说明**

- A→B 路径强度：0.9
- A→C 可走 A→B→C：`0.9 * 0.8 = 0.72`
- A→D：0.6
- A→E 可走 A→D→E：`0.6 * 0.95 = 0.57`
   因此 `sim(A,·)`：B=0.9，C=0.72，D=0.6，E=0.57

按相似度排序，平局再看评分：
 Top-3 = **["B","D","C"]**（若仅看相似度则 ["B","C","D"]，但 D 评分 8.8 > C 7.5，若 tie 才用评分；此例无 tie，仅演示次序规则）

**输出**

```
["B","C","D"]   # 或按你与面试官约定的 tie-break 输出，保持一致即可
```

> 注：若题面要求“将评分也并入相似度得分”（例如最终得分 `sim * rating`），请在题面中**明确**最终排序分数的定义，并据此排序。

## 边界与说明

- 若 `n ≤ 0` 返回空列表。
- 若 `query_movie` 不在图中，返回空列表或报错（题面需固定行为）。
- 若存在权重为 0 的边，可直接忽略（或按业务约定处理）。
- 有向图时仅遵循输入方向；若需要双向相似必须显式提供或设置 `undirected=True`。
- 请保证不把 `query_movie` 本身返回到结果中。

## 进阶（可选 Follow-ups）

1. **仅返回一跳/两跳内的候选**（限制最大路径长度），可在 Dijkstra/BFS 中加深度约束；或使用 `decay < 1` 抑制长路径。
2. **性能优化**：分批提前终止（当堆顶分数低于当前第 n 名时提早结束）、离线多源查询（共享一次预处理）。
3. **冷启动**：当源电影无相似边时，仅使用同类型/同导演/高评分的回退策略（题外）。
4. **去噪**：对多路径求和而非取最大（需避免路径爆炸，可限制条数或用 PPR）。