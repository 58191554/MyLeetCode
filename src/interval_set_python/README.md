# IntervalSet — 插入区间与点查询

## 问题描述

设计并实现一个“区间集合类” `IntervalSet`，支持两类操作：

1. `insert(l, r)`：向集合插入闭区间 **[l, r]**。
   - 允许与已存在区间重叠；**默认语义：自动合并**所有与之相交或相邻（可选）的区间（见“合并语义”）。
2. `query(x) -> bool`：判断点 `x` 是否落入集合中**任一**已插入的区间（在合并后的语义下）。

### 合并语义（默认约定）

- 区间类型：**闭区间** `[l, r]`。
- **自动合并**：当插入 `[l, r]` 时，与现有区间中**有交集**的都合并为单一大区间。
   （可选：是否把“相邻” `[1,2]` 与 `[3,4]` 合并为 `[1,4]`，即端点是否“黏合”。下面默认**不黏合**，需相交才合并。）
- 无效输入：若 `l > r`，应报错或忽略（实现自行约定）。

## 目标

- 给出合理的数据结构设计，使 `insert` 与 `query` 的时间复杂度满足预期。
- 面试中需要根据**操作比例**（查询多或插入多）与**是否离线**（是否能提前拿到全部输入）给出不同优化方案。

## 典型接口（任选其一说明即可）

**Python**

```python
class IntervalSet:
    def insert(self, l: int, r: int) -> None: ...
    def query(self, x: int) -> bool: ...
```

**C++**

```cpp
class IntervalSet {
public:
    void insert(long long l, long long r);
    bool query(long long x) const;
};
```

## 输入规模（建议向面试官确认；默认假设）

- 值域：`l, r, x` 为有符号 64 位整数（或 32 位；按语言限定）。
- 操作次数：`N_insert, N_query` 均可达 `1e5 ~ 2e5` 量级。
- 在线 / 离线：
  - **在线**：`insert` 与 `query` 交错到达，无法预知后续输入。
  - **离线**：所有操作在开始前已知，可预处理。

## 示例

```
ops:
insert(1, 3)         // 集合 = [1,3]
insert(6, 8)         // 集合 = [1,3], [6,8]
query(2)  -> True    // 2 ∈ [1,3]
query(4)  -> False   // 4 不在任一区间
insert(3, 6)         // 与 [1,3]、[6,8] 均相交（含端点相交），合并为 [1,8]
query(5)  -> True    // 5 ∈ [1,8]
```

## 边界与细则

- 允许重复插入相同区间（效果等同于一次）。
- 大量重叠的区间应被压缩为若干不相交区间（维护不相交链表/映射）。
- 若需要**相邻黏合**（`[1,2]` 与 `[3,4]` 视为相交），请在题面明确；默认**不黏合**。
- 空集合查询恒为 `False`。

------

# 设计与复杂度（按场景）

## 场景 A：查询远多于插入（Query-heavy）

**数据结构：有序映射 / 平衡树（C++ `std::map`，Java `TreeMap`；Python 可用 `bisect`+数组或第三方 `sortedcontainers`）**

- 维护若干互不重叠的区间，按左端点排序。
- `insert(l, r)`：
  - 用二分/下界找到第一个可能与 `[l, r]` 相交的区间，向左右扩展合并，删除旧区间并插入新合并区间。
  - **时间复杂度**：`O(k log M)`（`k` 为被合并区间数，`M` 为当前区间个数）。均摊常见为 `O(log M)`。
- `query(x)`：
  - 二分找到左端点不大于 `x` 的最大区间，检查 `x` 是否 ≤ 该区间右端点。
  - **时间复杂度**：`O(log M)`。

> 适用：读多写少；需要在线响应；内存 `O(M)`。

## 场景 B：插入远多于查询（Insert-heavy）

**思路 1：仍用有序映射**（实现简单，插入合并均摊良好）。
 **思路 2：批量压缩（离线或分批）**

- 将大量 `insert` 先缓存（只存原始区间），当需要查询或批量到达一定阈值时，**一次性归并**所有区间（排序+线扫）。
- 归并后查询 `O(log M)` 很快；插入阶段为摊销的 `O(1)` 记录，集中成本在归并时 `O(K log K)`（`K` 为待并区间数）。

## 场景 C：离线（所有操作已知，可预处理）

**离线扫描线 / 差分 + 坐标压缩**

- 收集所有端点与查询点，**离散化**到 `[0..U)`；
- 对每个插入区间在离散坐标上做区间加法（差分）；
- 前缀和后得到覆盖计数数组；
- 查询点直接 `O(1)` 查看对应位置是否被覆盖（>0）。
- **构建复杂度**：`O((N_insert + N_query) log U)`（离散化排序）+ `O(U)` 扫描；
- **查询复杂度**：`O(1)`；内存 `O(U)`。

> 适用：一次性大量查询、对延迟极敏感，且可接受预处理与离散化带来的内存开销。

## 场景 D：动态大量区间且需要更丰富操作（可选）

- **区间树 / 线段树 / 平衡树存区间**：支持区间覆盖、删除、交/并查询等（实现复杂度更高）；
- 若值域很大且稀疏，仍优先考虑“有序映射 + 合并区间”的方法。

------

# 复杂度对照（默认“有序映射 + 合并”方案）

- `insert(l, r)`: `O(k log M)`（常见均摊近似 `O(log M)`）
- `query(x)`: `O(log M)`
- 空间：`O(M)`（合并后区间数）

------

# 常见 Clarify 点（面试中要主动问清）

1. 区间是**闭区间**还是开/半开？相邻是否黏合？
2. 输入有效性：`l <= r` 的保证？异常如何处理？
3. 值域与类型：是否 64 位整数？是否需要支持浮点（若是，比较与合并要考虑精度、公差 `eps`）？
4. 操作规模：`N_insert`、`N_query` 的数量级与在线/离线？
5. 是否需要**删除**区间、返回**当前总覆盖长度**、或支持**多线程**？

------

# 简短示例：预期行为

```
S = IntervalSet()
S.insert(1, 3)             # {[1,3]}
S.insert(8, 10)            # {[1,3], [8,10]}
S.insert(2, 9)             # 合并 -> {[1,10]}     // 因为与 [1,3]、[8,10] 都相交
S.query(0)   -> False
S.query(5)   -> True
S.query(11)  -> False
```

> 如果“相邻黏合”为真（例如把 `[1,3]` 与 `[4,5]` 合并），需把“是否相邻”判断改为 `next.l <= cur.r + 1`。