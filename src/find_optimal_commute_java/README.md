# 选择单一交通工具的最短路径（Time 优先，Cost 次之）

给定一个由字符串组成的网格 `grid`，其中每个格子要么是：

* `"S"`：起点（恰好 1 个）
* `"D"`：终点（恰好 1 个）
* `"1"…"N"`：表示可通行的某种交通工具编号（编号可能是多位数，例如 `"10"`）

另外给定两个长度为 `N` 的数组：

* `cost[i]`：使用 **工具 i+1** 每走一步的花费（cost）
* `time[i]`：使用 **工具 i+1** 每走一步所需时间（time）

你需要从 `S` 走到 `D`，运动规则如下：

1. 只能 **上下左右** 四个方向移动（每次移动一格）。
2. **从出发前选定一种交通工具 k（1 ≤ k ≤ N）后，整个路径上（除起点/终点外）只能经过编号为 `"k"` 的格子。**
   `"S"` 和 `"D"` 视为中立格，任何工具都可以从/到达。
3. 若使用工具 `k` 的最短路径步数为 `steps_k`，则

   * 总时间 `total_time_k = steps_k * time[k-1]`
   * 总花费 `total_cost_k = steps_k * cost[k-1]`

**目标：** 在所有能从 `S` 到 `D` 的工具中，选择使 `total_time` **最小** 的工具；若有并列，则选择 `total_cost` **最小** 的；若仍并列，选择 **编号最小** 的。
若没有任何工具能从 `S` 到 `D`，返回 `-1`。

---

## 函数签名（示例）

* Java：

  ```java
  int bestTransport(String[][] grid, int[] cost, int[] time)
  ```
* 返回值：最佳交通工具的编号（1…N）；无解返回 `-1`。

---

## 输入约束（建议）

* `1 ≤ R, C ≤ 200`（`grid` 的行列数）
* `1 ≤ N ≤ 50`
* `grid[i][j] ∈ {"S","D"} ∪ {"1","2",…,"N"}`（注意编号为字符串，可能多位）
* `S` 与 `D` 各出现一次，且位置不同
* `1 ≤ cost[i], time[i] ≤ 10^6`

---

## 判定与路径说明

* 步数 = 从 `S` 到 `D` 经过的 **移动次数**（进入相邻格子算 1 步）。
* 选择工具 `k` 后，只能在标记为 `"k"` 的格子上行走（`"S"`/`"D"` 例外可进入）。
* 对每个工具分别计算从 `S` 到 `D` 的 **最短步数**（若不可达则忽略该工具），再根据目标规则选出答案。

---

## 示例 1

**输入：**

```
grid =
S 1 1 2
2 1 2 2
2 1 1 D
3 3 1 2

cost = [3, 1, 5]
time = [1, 2, 1]
```

**解释：**

* 选工具 1：存在路径 `S -> (0,1) -> (1,1) -> (2,1) -> (2,2) -> D`，步数 `5`
  `total_time = 5 * 1 = 5`，`total_cost = 5 * 3 = 15`
* 选工具 2：无法连通至 `D`
* 选工具 3：无法从 `S` 出发进入 `"3"` 区域连到 `D`

**输出：**

```
1
```

---

## 示例 2（时间并列以 cost 决胜）

**输入：**

```
grid =
S 1 1 1
2 2 2 D

cost = [5, 3]
time = [2, 2]
```

**解释：**
工具 1 的最短步数 = 4，`total_time = 8`，`total_cost = 20`
工具 2 的最短步数 = 4，`total_time = 8`，`total_cost = 12`
时间相同，选 cost 更小的工具 2。

**输出：**

```
2
```

---

## 示例 3（无可达路径）

**输入：**

```
grid =
S 4 4
4 4 4
4 4 D

cost = [1,1,1]
time = [1,1,1]
```

**输出：**

```
-1
```

---

## 示例 4（多位编号）

**输入：**

```
grid =
S 10 10 D

cost = [x1, x2, x3, x4, x5, x6, x7, x8, x9, 2]   // 长度为 10
time = [y1, y2, y3, y4, y5, y6, y7, y8, y9, 1]   // 长度为 10
```

**解释：** 只有工具 **10** 的通道可达 `D`，因此答案为 `10`。

**输出：**

```
10
```

---

# Follow up
能否只BFS一遍？