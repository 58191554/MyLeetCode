不属于力扣原题（LeetCode 没有“是否存在任意三点共线”的对应编号）。最接近的是：

- **149. Max Points on a Line**（求同一直线最多点数）
- **1232. Check If It Is a Straight Line**（判断所有点是否共线）

下面给你一份可直接用于面试/作业的正式题面。

# Exist Three Collinear Points

## 问题描述

给定平面上的一组点 `points = [(x1,y1), (x2,y2), ..., (xn,yn)]`（整数坐标），判断是否**存在三个不同的点**位于同一条直线上。若存在返回 `True`，否则返回 `False`。

> 三点共线当且仅当其组成的三角形面积为 0。可用向量叉积/行列式判断。

## 函数签名（Python）

```python
from typing import List, Tuple

def exist_three_collinear(points: List[Tuple[int, int]]) -> bool: ...
```

## 约束（可与面试官确认，给出一组合理默认）

- `1 ≤ n ≤ 2 * 10^5`
- 坐标为 32/64 位整数：`|xi|, |yi| ≤ 10^9`
- 可能包含**重复点**（需明确是否允许；默认允许，且重复点与任意两点共线仍视为成立）

## 示例

```
输入: points = [(0,0),(1,1),(2,2)]
输出: True   # (0,0),(1,1),(2,2) 共线

输入: points = [(0,0),(1,2),(2,1),(3,4)]
输出: False
```

## 判定方法与复杂度

### 方案 A（推荐，O(n^2) 均摊可过中等规模）

- 枚举每个锚点 `i`，用哈希表统计“与 i 构成的斜率（或方向向量的约分形式）”出现次数：
  - 对每个 `j > i`，方向向量 `dx = xj - xi`, `dy = yj - yi`；
  - 约分为**最简有向分数**（用 `g = gcd(dx, dy)`，并规范符号：让 `dx ≥ 0`，若 `dx == 0` 则令 `dy = 1/-1`）；
  - 在 `map[(dx/g, dy/g)] += 1`；
  - 若某个方向计数达到 **2**（即与锚点同方向至少出现 2 个点），则存在三点共线，返回 `True`。
- 同时记录 `duplicates`（`dx==0 && dy==0`），它们对所有斜率都“加成”，但只要锚点与两个非重复点同坡或一个非重复+一个重复即可满足。
- 若所有锚点处理完未命中，返回 `False`。
- 复杂度：`O(n^2)` 时间，`O(n)` 额外空间；适合 `n ≤ 2e4~5e4` 级别（视常数与语言而定）。

### 方案 B（小规模，三重循环 O(n^3)）

- 直接三重枚举 `(i,j,k)`，用叉积判断
   `cross( Pj-Pi, Pk-Pi ) = 0`：
   `(xj-xi)*(yk-yi) == (yj-yi)*(xk-xi)`。
- 仅适合很小的 `n`（如 `n ≤ 400`）。

### 叉积判零（避免浮点误差）

- 使用整数计算：

  ```
  collinear(i,j,k) ⇔ (xj - xi) * (yk - yi) == (yj - yi) * (xk - xi)
  ```

## 边界与细则

- `n < 3` 直接返回 `False`。
- 出现重复点：
  - 若有一点与某对不同点共线即返回 `True`；
  - 三个完全相同的点也视为共线（按“一条直线可以包含无限多个重合点”的常规定义）。
- 可选：若仅需答案而非效率，可先随机抽样若干锚点加速；或当 `n` 很大可在前若干个锚点上做概率化判定（面试时说明权衡）。

------

需要的话，我可以给你一份 **O(n^2)** 的 Python 参考实现（考虑 `gcd` 约分与重复点），或一份小规模的三重循环版本来做单测基线。