不是力扣原题，但最接近的是：

- **LeetCode 974. Subarray Sums Divisible by K**（统计个数，判定版可改成是否存在）
- **LeetCode 523. Continuous Subarray Sum**（判断是否存在和为 K 的倍数的子数组）

下面给出这道题的**正式题面**（含示例与函数名按你给的要求）。

# HasSubarrayKMod6e6

## 题目描述

给定一个正整数数组 `nums` 和一个整数 `k`，判断是否存在**非空的连续子数组** `nums[l..r]`，使得

```
( nums[l] + nums[l+1] + ... + nums[r] ) mod 6,000,009 == k
```

若存在返回 `True`，否则返回 `False`。

> 记 `M = 6_000_009`。当 `k` 不在 `[0, M-1]` 范围内时，按 `k = ((k % M) + M) % M` 归一化后再判断。

## 函数签名（Python）

```python
def HasSubarrayKMod6e6(nums: list[int], k: int) -> bool: ...
```

## 示例

```
输入：nums = [3, 1, 4, 2], k = 5
解释：取子数组 [3,1,4]，其和为 8，8 mod 6,000,009 = 8；不满足。
      取子数组 [1,4]，其和为 5，5 mod 6,000,009 = 5；满足。
输出：True
```

## 思路提示（可直接在面试中口述）

- 设前缀和 `pref[i] = nums[0]+...+nums[i-1]`，对 `M` 取模为 `r[i] = pref[i] % M`。
- 目标是找 `i < j` 使 ` (pref[j] - pref[i]) % M == k`
   等价于 ` r[j] == (r[i] + k) % M`。
- 扫描数组，维护已见到的 `r[i]` 集合（或哈希表）。到达位置 `j` 时检查是否存在某个已见余数等于 `(r[j] - k) % M`。
- 时间 `O(n)`，空间 `O(Min(n, M))`。

## 复杂度

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`（使用哈希集合/哈希表）

## 细节与边界

- 子数组必须**非空**。
- 允许 `k` 为负数或大于 `M`，需先按模 `M` 归一化。
- 若只需判断“是否存在”，遇到命中即可提前返回。